        -:    0:Source:drinks_bar.cpp
        -:    0:Graph:drinks_bar.gcno
        -:    0:Data:drinks_bar.gcda
        -:    0:Runs:6
        -:    1:#include <iostream>
        -:    2:#include <sstream>
        -:    3:#include <string>
        -:    4:#include <vector>
        -:    5:#include <map>
        -:    6:#include <array>
        -:    7:#include <cstring>
        -:    8:#include <cstdlib>
        -:    9:#include <unistd.h>
        -:   10:#include <fcntl.h>
        -:   11:#include <sys/types.h>
        -:   12:#include <sys/socket.h>
        -:   13:#include <netinet/in.h>
        -:   14:#include <arpa/inet.h>
        -:   15:#include <set>
        -:   16:#include <algorithm>
        -:   17:#include <getopt.h>
        -:   18:#include <sys/time.h>
        -:   19:#include <signal.h>
        -:   20:
        -:   21:constexpr size_t READ_BUFFER = 1024;
        -:   22:constexpr unsigned long long MAX_ATOMS = 1000000000000000000ULL;
        -:   23:
        -:   24:static volatile sig_atomic_t keep_running = 1;
        -:   25:
        -:   26:// Map molecule name to its atom requirements: {C, H, O}
        -:   27:const std::map<std::string, std::array<unsigned long long,3>> molecule_req = {
        -:   28:    {"WATER",          {0, 2, 1}}, // H2O
        -:   29:    {"CARBON DIOXIDE", {1, 0, 2}}, // CO2
        -:   30:    {"GLUCOSE",        {6, 12, 6}}, // C6H12O6
        -:   31:    {"ALCOHOL",        {2, 6, 1}}, // C2H6O
        -:   32:};
        -:   33:
        4:   34:int setNonBlocking(int fd) {
        4:   35:    int flags = fcntl(fd, F_GETFL, 0);
       4*:   36:    return (flags < 0) ? -1 : fcntl(fd, F_SETFL, flags | O_NONBLOCK);
        -:   37:}
        -:   38:
        4:   39:void sendTCPStatus(int fd, unsigned long long carbon, unsigned long long oxygen, unsigned long long hydrogen) {
        4:   40:    std::ostringstream oss;
        4:   41:    oss << "CARBON: " << carbon << "\n"
        4:   42:        << "OXYGEN: " << oxygen << "\n"
        4:   43:        << "HYDROGEN: " << hydrogen << "\n";
        4:   44:    std::string status = oss.str();
        4:   45:    send(fd, status.c_str(), status.size(), 0);
        4:   46:}
        -:   47:
        8:   48:void processTCPCommand(int fd, const std::string& line, unsigned long long& carbon, unsigned long long& oxygen, unsigned long long& hydrogen) {
        8:   49:    std::istringstream iss(line);
        8:   50:    std::string cmd, type;
        -:   51:    unsigned long long amount;
        -:   52:
        8:   53:    if(!(iss >> cmd >> type >> amount) || cmd != "ADD" || amount > MAX_ATOMS) {
        2:   54:        const char* err = "ERROR: Invalid command\n";
        2:   55:        send(fd, err, strlen(err), 0);
        2:   56:        return;
        -:   57:    }
        -:   58:
        6:   59:    unsigned long long *counter = nullptr;
        6:   60:    if (type == "CARBON") {
        3:   61:        counter = &carbon;
        3:   62:    } else if (type == "HYDROGEN") {
        1:   63:        counter = &hydrogen;
        2:   64:    } else if (type == "OXYGEN") {
        1:   65:        counter = &oxygen;
        -:   66:    } else {
        1:   67:        const char* err = "ERROR: Unknown atom type\n";
        1:   68:        send(fd, err, strlen(err), 0);
        1:   69:        return;
        -:   70:    }
        -:   71:
        5:   72:    if (*counter + amount > MAX_ATOMS || *counter + amount < *counter) {
        1:   73:        const char* err = "ERROR: Overflow error\n";
        1:   74:        send(fd, err, strlen(err), 0);
        1:   75:        return;
        -:   76:    }
        -:   77:
        4:   78:    *counter += amount;
        4:   79:    sendTCPStatus(fd, carbon, oxygen, hydrogen);
       16:   80:}
        -:   81:
        6:   82:void processUDPCommand(int sock, const std::string& line, const sockaddr_in& cli_addr, socklen_t cli_len, unsigned long long& carbon, unsigned long long& oxygen, unsigned long long& hydrogen) {
        6:   83:    std::istringstream iss(line);
        6:   84:    std::string cmd;
        -:   85:    unsigned long long count;
        6:   86:    if (!(iss >> cmd) || cmd != "DELIVER") {
        1:   87:        const char* err = "ERROR: invalid command";
        1:   88:        sendto(sock, err, strlen(err), 0,
        -:   89:               (const sockaddr*)&cli_addr, cli_len);
        1:   90:        return;
        -:   91:    }
        -:   92:    // reconstruct molecule name (rest of tokens except last)
        5:   93:    std::vector<std::string> tokens;
        5:   94:    std::string token;
       14:   95:    while (iss >> token)
        9:   96:        tokens.push_back(token);
        5:   97:    if (tokens.size() < 2) {
        1:   98:        const char* err = "ERROR: invalid command";
        1:   99:        sendto(sock, err, strlen(err), 0,
        -:  100:               (const sockaddr*)&cli_addr, cli_len);
        1:  101:        return;
        -:  102:    }
        -:  103:    // last token is count
        -:  104:    try {
        4:  105:        count = std::stoull(tokens.back());
    =====:  106:    } catch (...) {
    =====:  107:        const char* err = "ERROR: invalid number";
    =====:  108:        sendto(sock, err, strlen(err), 0,
        -:  109:               (const sockaddr*)&cli_addr, cli_len);
    =====:  110:        return;
    =====:  111:    }
        -:  112:    // join tokens[0..n-2] into molecule name
        4:  113:    std::string mol = tokens[0];
       4*:  114:    for (size_t i = 1; i + 1 < tokens.size(); ++i) {
    #####:  115:        mol += " ";
    #####:  116:        mol += tokens[i];
        -:  117:    }
        4:  118:    auto it = molecule_req.find(mol);
        4:  119:    if (it == molecule_req.end()) {
    #####:  120:        const char* err = "ERROR: unknown molecule";
    #####:  121:        sendto(sock, err, strlen(err), 0,
        -:  122:               (const sockaddr*)&cli_addr, cli_len);
    #####:  123:        return;
        -:  124:    }
        4:  125:    auto req = it->second; // {C, H, O}
        4:  126:    unsigned long long needC = req[0] * count;
        4:  127:    unsigned long long needH = req[1] * count;
        4:  128:    unsigned long long needO = req[2] * count;
        4:  129:    if (carbon >= needC && hydrogen >= needH && oxygen >= needO) {
        2:  130:        carbon   -= needC;
        2:  131:        hydrogen -= needH;
        2:  132:        oxygen   -= needO;
        2:  133:        std::ostringstream oss;
        -:  134:        oss << "OK" << "\n" 
        2:  135:        << "CARBON: " << carbon << "\n"
        2:  136:        << "OXYGEN: " << oxygen << "\n"
        2:  137:        << "HYDROGEN: " << hydrogen;
        2:  138:        std::string ok = oss.str();
        2:  139:        sendto(sock, ok.c_str(), ok.size(), 0, (const sockaddr*)&cli_addr, cli_len);
        2:  140:    } else {
        2:  141:        const char* err = "ERROR: insufficient atoms";
        2:  142:        sendto(sock, err, strlen(err), 0, (const sockaddr*)&cli_addr, cli_len);
        -:  143:    }
       10:  144:}
        -:  145:
        1:  146:void signalHandler(int) {
        1:  147:    keep_running = 0;
        1:  148:}
        -:  149:
        6:  150:int main(int argc, char* argv[]) {
        -:  151:
        6:  152:    unsigned long long initcarbon = 0, initoxygen = 0, inithydrogen = 0;
        6:  153:    int timeout_seconds = -1;
        6:  154:    int tcp_port = -1, udp_port = -1;
        -:  155:
        6:  156:    signal(SIGINT, signalHandler);
        -:  157:
        -:  158:    static struct option long_options[] = {
        -:  159:        {"oxygen", required_argument, nullptr, 'o'},
        -:  160:        {"hydrogen", required_argument, nullptr, 'h'},
        -:  161:        {"carbon", required_argument, nullptr, 'c'},
        -:  162:        {"timeout", required_argument, nullptr, 't'},
        -:  163:        {"tcp-port", required_argument, nullptr, 'T'},
        -:  164:        {"udp-port", required_argument, nullptr, 'U'},
        -:  165:        {nullptr, 0, nullptr, 0}
        -:  166:    };
        -:  167:    
        -:  168:    int opt;
       14:  169:    while ((opt = getopt_long(argc, argv, "o:h:c:t:T:U:", long_options, nullptr)) != -1) {
        8:  170:        switch (opt) {
    #####:  171:            case 'o':
    #####:  172:                initoxygen = std::stoull(optarg);
    #####:  173:                break;
    #####:  174:            case 'h':
    #####:  175:                inithydrogen = std::stoull(optarg);
    #####:  176:                break;
    #####:  177:            case 'c':
    #####:  178:                initcarbon = std::stoull(optarg);
    #####:  179:                break;
    #####:  180:            case 't':
    #####:  181:                timeout_seconds = std::stoi(optarg);
    #####:  182:                break;
        4:  183:            case 'T':
        4:  184:                tcp_port = std::stoi(optarg);
        4:  185:                break;
        4:  186:            case 'U':
        4:  187:                udp_port = std::stoi(optarg);
        4:  188:                break;
    #####:  189:            default:
    #####:  190:                std::cerr << "Usage: " << argv[0] << " [-o amount] [-c amount] [-h amount] [-t seconds] [-T port] [-U port] \n";
    #####:  191:                return 1;
        -:  192:        }
        -:  193:    }
        -:  194:
        6:  195:    if (tcp_port < 0 || udp_port < 0){
        2:  196:        std::cerr << "ERROR: TCP and UDP ports must be specified\n";
        2:  197:        return 1;
        -:  198:    }
        -:  199:
        4:  200:    unsigned long long carbon = initcarbon;
        4:  201:    unsigned long long oxygen = initoxygen;
        4:  202:    unsigned long long hydrogen = inithydrogen;
        -:  203:
        8:  204:    std::set<std::string> udp_peers;
        -:  205:
        -:  206:    // --- TCP socket setup ---
        4:  207:    int listener = socket(AF_INET, SOCK_STREAM, 0);
        4:  208:    if (listener < 0) {
    #####:  209:        std::cerr << "Error creating TCP socket\n";
    #####:  210:        return 1;
        -:  211:    }
        4:  212:    int sockopt = 1;
        4:  213:    setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &sockopt, sizeof(opt));
        4:  214:    sockaddr_in addr{};
        4:  215:    addr.sin_family = AF_INET;
        4:  216:    addr.sin_addr.s_addr = INADDR_ANY;
        4:  217:    addr.sin_port = htons(tcp_port);
        4:  218:    if (bind(listener, (sockaddr*)&addr, sizeof(addr)) < 0) {
        2:  219:        std::cerr << "Error binding TCP socket\n";
        2:  220:        return 1;
        -:  221:    }
        2:  222:    if (listen(listener, SOMAXCONN) < 0) {
    #####:  223:        std::cerr << "Error listening on TCP socket\n";
    #####:  224:        return 1;
        -:  225:    }
        2:  226:    setNonBlocking(listener);
        -:  227:    
        -:  228:
        -:  229:    // --- UDP socket setup ---
        2:  230:    int udpSock = socket(AF_INET, SOCK_DGRAM, 0);
        2:  231:    if (udpSock < 0) {
    #####:  232:        std::cerr << "Error creating UDP socket\n";
    #####:  233:        return 1;
        -:  234:    }
        2:  235:    sockaddr_in udp_addr{};
        2:  236:    udp_addr.sin_family = AF_INET;
        2:  237:    udp_addr.sin_addr.s_addr = INADDR_ANY;
        2:  238:    udp_addr.sin_port = htons(udp_port);
        2:  239:    if(bind(udpSock, (sockaddr*)&udp_addr, sizeof(udp_addr)) < 0) {
        1:  240:        std::cerr << "Error binding UDP socket\n";
        1:  241:        return 1;
        -:  242:    }
        1:  243:    setNonBlocking(udpSock);
        -:  244:
        -:  245:    // Shared state
        2:  246:    std::vector<int> clients;
        1:  247:    std::map<int, std::string> recv_buffer;
        -:  248:
        -:  249:    fd_set read_fds;
       20:  250:    while (keep_running) {
      340:  251:        FD_ZERO(&read_fds);
       20:  252:        FD_SET(STDIN_FILENO, &read_fds);
       20:  253:        FD_SET(listener, &read_fds);
       20:  254:        FD_SET(udpSock, &read_fds);
        -:  255:
       29:  256:        for(int fd : clients) {
        9:  257:            FD_SET(fd, &read_fds);
        -:  258:        }
        -:  259:
       20:  260:        int max_fd = listener;
       20:  261:        max_fd = std::max(max_fd, udpSock);
       20:  262:        max_fd = std::max(max_fd, STDIN_FILENO);
       29:  263:        for(int fd : clients) {
        9:  264:            max_fd = std::max(max_fd, fd);
        -:  265:        }
        -:  266:
        -:  267:        struct timeval timeout;
       20:  268:        struct timeval* timeout_ptr = nullptr;
        -:  269:
       20:  270:        if(timeout_seconds >= 0) {
    #####:  271:            timeout.tv_sec = timeout_seconds;
    #####:  272:            timeout.tv_usec = 0;
    #####:  273:            timeout_ptr = &timeout;
        -:  274:        } 
        -:  275:
       20:  276:        int ready = select(max_fd + 1, &read_fds, nullptr, nullptr, timeout_ptr);
       20:  277:        if (ready < 0) {
        1:  278:            std::cerr << "Error in select\n";
        1:  279:            break;
        -:  280:        }
       19:  281:        if(ready == 0) {
    #####:  282:            std::cout << "Timout occurred, no activity detected for " << timeout_seconds << " seconds.\n";
    #####:  283:            break;
        -:  284:        }
        -:  285:
       19:  286:        if(FD_ISSET(STDIN_FILENO, &read_fds)) {
        3:  287:            std::string input;
        3:  288:            if(std::getline(std::cin, input) ) {
        3:  289:               if(input == "GEN SOFT DRINK"){
        1:  290:                    auto nwater = std::min(hydrogen / 2, oxygen);
        1:  291:                    auto nco2 = std::min(carbon, oxygen / 2);
        1:  292:                    auto nglucose = std::min({carbon / 6, hydrogen / 12, oxygen / 6});
        1:  293:                    auto softdrinksamount = std::min({nwater, nco2, nglucose});
        1:  294:                    std::cout << "SOFT DRINK: " << softdrinksamount << "\n";
        -:  295:               }
        2:  296:               else if(input == "GEN VODKA"){
    #####:  297:                    auto nwater = std::min(hydrogen / 6, oxygen);
    #####:  298:                    auto nalcohol = std::min({carbon / 2, hydrogen / 6, oxygen});
    #####:  299:                    auto nglucose = std::min({carbon / 2, hydrogen / 12, oxygen / 6});
    #####:  300:                    auto vodkaamount = std::min({nwater, nalcohol, nglucose});
    #####:  301:                    std::cout << "VODKA: " << vodkaamount << "\n";
        -:  302:               }
        2:  303:               else if(input == "GEN CHAMPAGNE"){
        2:  304:                    auto nwater = std::min(hydrogen / 2, oxygen);
        2:  305:                    auto nco2 = std::min(carbon, oxygen / 2);
        2:  306:                    auto nalcohol = std::min({carbon / 2, hydrogen / 6, oxygen});
        2:  307:                    auto champagneamount = std::min({nwater, nco2, nalcohol});
        2:  308:                    std::cout << "CHAMPAGNE: " << champagneamount << "\n";
        -:  309:               }
        -:  310:               else{
    #####:  311:                   std::cout << "Unknown command\n";
        -:  312:               }
        -:  313:            }
        3:  314:        }
        -:  315:
        -:  316:        // Handle new TCP connections
       19:  317:        if (FD_ISSET(listener, &read_fds)) {
        1:  318:            sockaddr_in cli_addr{};
        1:  319:            socklen_t cli_len = sizeof(cli_addr);
        1:  320:            int client_fd = accept(listener, (sockaddr*)&cli_addr, &cli_len);
       1*:  321:            if( client_fd < 0) {
    #####:  322:                std::cerr << "Error accepting TCP connection\n";
    #####:  323:                continue;
        -:  324:            }
        1:  325:            setNonBlocking(client_fd);
        1:  326:            clients.push_back(client_fd);
        1:  327:            std::cout << "New TCP client connected: " << inet_ntoa(cli_addr.sin_addr) << ":" << ntohs(cli_addr.sin_port) << "\n";
        -:  328:        }
        -:  329:        // Handle UDP requests
       19:  330:        if (FD_ISSET(udpSock, &read_fds)) {
        -:  331:            char buf[READ_BUFFER];
        6:  332:            sockaddr_in cli_addr{};
        6:  333:            socklen_t cli_len = sizeof(cli_addr);
        6:  334:            ssize_t n = recvfrom(udpSock, buf, sizeof(buf), 0, (sockaddr*)&cli_addr, &cli_len);
        6:  335:            if (n < 0) {
    #####:  336:                std::cerr << "Error receiving UDP data\n";
    #####:  337:                break;
        -:  338:            }
        -:  339:            char ip[INET_ADDRSTRLEN];
        6:  340:            inet_ntop(AF_INET, &cli_addr.sin_addr, ip, sizeof(ip));
        6:  341:            int port = ntohs(cli_addr.sin_port);
       12:  342:            std::string peer_id = std::string(ip) + ":" + std::to_string(port);
        6:  343:            if (udp_peers.insert(peer_id).second) {
        1:  344:                std::cout << "New UDP client connected: " << peer_id << "\n";
        -:  345:            }
        -:  346:
        6:  347:            std::string cmd(buf, n);
       6*:  348:            if (!cmd.empty() && cmd.back() == '\n')
        6:  349:                cmd.pop_back(); // Remove trailing newline
        -:  350:
        6:  351:            processUDPCommand(udpSock, cmd, cli_addr, cli_len, carbon, oxygen, hydrogen);
        6:  352:        }
        -:  353:        
       29:  354:        for(auto it = clients.begin(); it != clients.end();) {
       10:  355:            int client_fd = *it;
       10:  356:            if (FD_ISSET(client_fd, &read_fds)) {
        -:  357:                char buffer[READ_BUFFER];
        9:  358:                ssize_t bytes_read = recv(client_fd, buffer, sizeof(buffer), 0);
        9:  359:                if (bytes_read <= 0) {
        1:  360:                    close(client_fd);
        1:  361:                    it = clients.erase(it);
        1:  362:                    std::cout << "TCP client disconnected\n";
        1:  363:                    continue;
        -:  364:                }
        8:  365:                buffer[bytes_read] = '\0';
        8:  366:                std::string line(buffer);
       8*:  367:                if (!line.empty() && line.back() == '\n')
        8:  368:                    line.pop_back();
        8:  369:                processTCPCommand(client_fd, line, carbon, oxygen, hydrogen);
        8:  370:            }
        9:  371:            ++it;
        -:  372:        }
        -:  373:    }
        -:  374:
       1*:  375:    for(int client_fd : clients) {
    #####:  376:        close(client_fd);
        -:  377:    }
        1:  378:    close(listener);
        1:  379:    close(udpSock);
        -:  380:
        1:  381:    return 0;
        -:  382:}
