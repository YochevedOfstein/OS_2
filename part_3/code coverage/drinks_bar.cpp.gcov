        -:    0:Source:drinks_bar.cpp
        -:    0:Graph:drinks_bar.gcno
        -:    0:Data:drinks_bar.gcda
        -:    0:Runs:2
        -:    1:#include <iostream>
        -:    2:#include <sstream>
        -:    3:#include <string>
        -:    4:#include <vector>
        -:    5:#include <map>
        -:    6:#include <array>
        -:    7:#include <cstring>
        -:    8:#include <cstdlib>
        -:    9:#include <unistd.h>
        -:   10:#include <fcntl.h>
        -:   11:#include <sys/types.h>
        -:   12:#include <sys/socket.h>
        -:   13:#include <netinet/in.h>
        -:   14:#include <arpa/inet.h>
        -:   15:#include <set>
        -:   16:#include <algorithm>
        -:   17:
        -:   18:constexpr size_t READ_BUFFER = 1024;
        -:   19:constexpr unsigned long long MAX_ATOMS = 1000000000000000000ULL;
        -:   20:
        -:   21:// Map molecule name to its atom requirements: {C, H, O}
        -:   22:const std::map<std::string, std::array<unsigned long long,3>> molecule_req = {
        -:   23:    {"WATER",          {0, 2, 1}}, // H2O
        -:   24:    {"CARBON DIOXIDE", {1, 0, 2}}, // CO2
        -:   25:    {"GLUCOSE",        {6, 12, 6}}, // C6H12O6
        -:   26:    {"ALCOHOL",        {2, 6, 1}}, // C2H6O
        -:   27:};
        -:   28:
    #####:   29:int setNonBlocking(int fd) {
    #####:   30:    int flags = fcntl(fd, F_GETFL, 0);
    #####:   31:    return (flags < 0) ? -1 : fcntl(fd, F_SETFL, flags | O_NONBLOCK);
        -:   32:}
        -:   33:
    #####:   34:void sendTCPStatus(int fd, unsigned long long carbon, unsigned long long oxygen, unsigned long long hydrogen) {
    #####:   35:    std::ostringstream oss;
    #####:   36:    oss << "CARBON: " << carbon << "\n"
    #####:   37:        << "OXYGEN: " << oxygen << "\n"
    #####:   38:        << "HYDROGEN: " << hydrogen << "\n";
    #####:   39:    std::string status = oss.str();
    #####:   40:    send(fd, status.c_str(), status.size(), 0);
    #####:   41:}
        -:   42:
    #####:   43:void processTCPCommand(int fd, const std::string& line, unsigned long long& carbon, unsigned long long& oxygen, unsigned long long& hydrogen) {
    #####:   44:    std::istringstream iss(line);
    #####:   45:    std::string cmd, type;
        -:   46:    unsigned long long amount;
        -:   47:
    #####:   48:    if(!(iss >> cmd >> type >> amount) || cmd != "ADD" || amount > MAX_ATOMS) {
    #####:   49:        const char* err = "ERROR: Invalid command\n";
    #####:   50:        send(fd, err, strlen(err), 0);
    #####:   51:        return;
        -:   52:    }
        -:   53:
    #####:   54:    unsigned long long *counter = nullptr;
    #####:   55:    if (type == "CARBON") {
    #####:   56:        counter = &carbon;
    #####:   57:    } else if (type == "HYDROGEN") {
    #####:   58:        counter = &hydrogen;
    #####:   59:    } else if (type == "OXYGEN") {
    #####:   60:        counter = &oxygen;
        -:   61:    } else {
    #####:   62:        const char* err = "ERROR: Unknown atom type\n";
    #####:   63:        send(fd, err, strlen(err), 0);
    #####:   64:        return;
        -:   65:    }
        -:   66:
    #####:   67:    if (*counter + amount > MAX_ATOMS || *counter + amount < *counter) {
    #####:   68:        const char* err = "ERROR: Overflow error\n";
    #####:   69:        send(fd, err, strlen(err), 0);
    #####:   70:        return;
        -:   71:    }
        -:   72:
    #####:   73:    *counter += amount;
    #####:   74:    sendTCPStatus(fd, carbon, oxygen, hydrogen);
    #####:   75:}
        -:   76:
    #####:   77:void processUDPCommand(int sock, const std::string& line, const sockaddr_in& cli_addr, socklen_t cli_len, unsigned long long& carbon, unsigned long long& oxygen, unsigned long long& hydrogen) {
    #####:   78:    std::istringstream iss(line);
    #####:   79:    std::string cmd;
        -:   80:    unsigned long long count;
    #####:   81:    if (!(iss >> cmd) || cmd != "DELIVER") {
    #####:   82:        const char* err = "ERROR: invalid command\n";
    #####:   83:        sendto(sock, err, strlen(err), 0,
        -:   84:               (const sockaddr*)&cli_addr, cli_len);
    #####:   85:        return;
        -:   86:    }
        -:   87:    // reconstruct molecule name (rest of tokens except last)
    #####:   88:    std::vector<std::string> tokens;
    #####:   89:    std::string token;
    #####:   90:    while (iss >> token)
    #####:   91:        tokens.push_back(token);
    #####:   92:    if (tokens.size() < 2) {
    #####:   93:        const char* err = "ERROR: invalid command\n";
    #####:   94:        sendto(sock, err, strlen(err), 0,
        -:   95:               (const sockaddr*)&cli_addr, cli_len);
    #####:   96:        return;
        -:   97:    }
        -:   98:    // last token is count
        -:   99:    try {
    #####:  100:        count = std::stoull(tokens.back());
    =====:  101:    } catch (...) {
    =====:  102:        const char* err = "ERROR: invalid number\n";
    =====:  103:        sendto(sock, err, strlen(err), 0,
        -:  104:               (const sockaddr*)&cli_addr, cli_len);
    =====:  105:        return;
    =====:  106:    }
        -:  107:    // join tokens[0..n-2] into molecule name
    #####:  108:    std::string mol = tokens[0];
    #####:  109:    for (size_t i = 1; i + 1 < tokens.size(); ++i) {
    #####:  110:        mol += " ";
    #####:  111:        mol += tokens[i];
        -:  112:    }
    #####:  113:    auto it = molecule_req.find(mol);
    #####:  114:    if (it == molecule_req.end()) {
    #####:  115:        const char* err = "ERROR: unknown molecule\n";
    #####:  116:        sendto(sock, err, strlen(err), 0,
        -:  117:               (const sockaddr*)&cli_addr, cli_len);
    #####:  118:        return;
        -:  119:    }
    #####:  120:    auto req = it->second; // {C, H, O}
    #####:  121:    unsigned long long needC = req[0] * count;
    #####:  122:    unsigned long long needH = req[1] * count;
    #####:  123:    unsigned long long needO = req[2] * count;
    #####:  124:    if (carbon >= needC && hydrogen >= needH && oxygen >= needO) {
    #####:  125:        carbon   -= needC;
    #####:  126:        hydrogen -= needH;
    #####:  127:        oxygen   -= needO;
    #####:  128:        std::ostringstream oss;
        -:  129:        oss << "OK" << "\n" 
    #####:  130:        << "CARBON: " << carbon << "\n"
    #####:  131:        << "OXYGEN: " << oxygen << "\n"
    #####:  132:        << "HYDROGEN: " << hydrogen << "\n" ;
    #####:  133:        std::string ok = oss.str();
    #####:  134:        sendto(sock, ok.c_str(), ok.size(), 0, (const sockaddr*)&cli_addr, cli_len);
    #####:  135:    } else {
    #####:  136:        const char* err = "ERROR: insufficient atoms\n";
    #####:  137:        sendto(sock, err, strlen(err), 0, (const sockaddr*)&cli_addr, cli_len);
        -:  138:    }
    #####:  139:}
        -:  140:
        2:  141:int main(int argc, char* argv[]) {
        2:  142:    std::set<std::string> udp_peers; // Track UDP peers if needed
        2:  143:    if (argc != 3) {
        2:  144:        std::cerr << "Usage: " << argv[0] << " <tcp_port> <udp_port>\n";
        2:  145:        return 1;
        -:  146:    }
    #####:  147:    int tcp_port = std::stoi(argv[1]);
    #####:  148:    int udp_port = std::stoi(argv[2]);
        -:  149:
        -:  150:    // --- TCP socket setup ---
    #####:  151:    int listener = socket(AF_INET, SOCK_STREAM, 0);
    #####:  152:    if (listener < 0) {
    #####:  153:        std::cerr << "Error creating TCP socket\n";
    #####:  154:        return 1;
        -:  155:    }
    #####:  156:    int opt = 1;
    #####:  157:    setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
    #####:  158:    sockaddr_in addr{};
    #####:  159:    addr.sin_family = AF_INET;
    #####:  160:    addr.sin_addr.s_addr = INADDR_ANY;
    #####:  161:    addr.sin_port = htons(tcp_port);
    #####:  162:    if (bind(listener, (sockaddr*)&addr, sizeof(addr)) < 0) {
    #####:  163:        std::cerr << "Error binding TCP socket\n";
    #####:  164:        return 1;
        -:  165:    }
    #####:  166:    if (listen(listener, SOMAXCONN) < 0) {
    #####:  167:        std::cerr << "Error listening on TCP socket\n";
    #####:  168:        return 1;
        -:  169:    }
    #####:  170:    setNonBlocking(listener);
        -:  171:    
        -:  172:
        -:  173:    // --- UDP socket setup ---
    #####:  174:    int udpSock = socket(AF_INET, SOCK_DGRAM, 0);
    #####:  175:    if (udpSock < 0) {
    #####:  176:        std::cerr << "Error creating UDP socket\n";
    #####:  177:        return 1;
        -:  178:    }
    #####:  179:    sockaddr_in udp_addr{};
    #####:  180:    udp_addr.sin_family = AF_INET;
    #####:  181:    udp_addr.sin_addr.s_addr = INADDR_ANY;
    #####:  182:    udp_addr.sin_port = htons(udp_port);
    #####:  183:    if(bind(udpSock, (sockaddr*)&udp_addr, sizeof(udp_addr)) < 0) {
    #####:  184:        std::cerr << "Error binding UDP socket\n";
    #####:  185:        return 1;
        -:  186:    }
    #####:  187:    setNonBlocking(udpSock);
        -:  188:
        -:  189:    // Shared state
    #####:  190:    std::vector<int> clients;
    #####:  191:    std::map<int, std::string> recv_buffer;
    #####:  192:    unsigned long long carbon = 0, oxygen = 0, hydrogen = 0;
        -:  193:
        -:  194:    fd_set read_fds;
        -:  195:    while (true) {
    #####:  196:        FD_ZERO(&read_fds);
    #####:  197:        FD_SET(STDIN_FILENO, &read_fds);
    #####:  198:        FD_SET(listener, &read_fds);
    #####:  199:        FD_SET(udpSock, &read_fds);
        -:  200:
    #####:  201:        for(int fd : clients) {
    #####:  202:            FD_SET(fd, &read_fds);
        -:  203:        }
        -:  204:
    #####:  205:        int max_fd = listener;
    #####:  206:        max_fd = std::max(max_fd, udpSock);
    #####:  207:        max_fd = std::max(max_fd, STDIN_FILENO);
    #####:  208:        for(int fd : clients) {
    #####:  209:            max_fd = std::max(max_fd, fd);
        -:  210:        }
        -:  211:
    #####:  212:        int ready = select(max_fd + 1, &read_fds, nullptr, nullptr, nullptr);
    #####:  213:        if (ready < 0) {
    #####:  214:            std::cerr << "Error in select\n";
    #####:  215:            break;
        -:  216:        }
        -:  217:
    #####:  218:        if(FD_ISSET(STDIN_FILENO, &read_fds)) {
    #####:  219:            std::string input;
    #####:  220:            if(std::getline(std::cin, input) ) {
    #####:  221:               if(input == "GEN SOFT DRINK"){
    #####:  222:                    auto nwater = std::min(hydrogen / 2, oxygen);
    #####:  223:                    auto nco2 = std::min(carbon, oxygen / 2);
    #####:  224:                    auto nglucose = std::min({carbon / 6, hydrogen / 12, oxygen / 6});
    #####:  225:                    auto softdrinksamount = std::min({nwater, nco2, nglucose});
    #####:  226:                    std::cout << "SOFT DRINK: " << softdrinksamount << "\n";
        -:  227:               }
    #####:  228:               else if(input == "GEN VODKA"){
    #####:  229:                    auto nwater = std::min(hydrogen / 6, oxygen);
    #####:  230:                    auto nalcohol = std::min({carbon / 2, hydrogen / 6, oxygen});
    #####:  231:                    auto nglucose = std::min({carbon / 2, hydrogen / 12, oxygen / 6});
    #####:  232:                    auto vodkaamount = std::min({nwater, nalcohol, nglucose});
    #####:  233:                    std::cout << "VODKA: " << vodkaamount << "\n";
        -:  234:               }
    #####:  235:               else if(input == "GEN CHAMPAGNE"){
    #####:  236:                    auto nwater = std::min(hydrogen / 2, oxygen);
    #####:  237:                    auto nco2 = std::min(carbon, oxygen / 2);
    #####:  238:                    auto nalcohol = std::min({carbon / 2, hydrogen / 6, oxygen});
    #####:  239:                    auto champagneamount = std::min({nwater, nco2, nalcohol});
    #####:  240:                    std::cout << "CHAMPAGNE: " << champagneamount << "\n";
        -:  241:               }
        -:  242:               else{
    #####:  243:                   std::cout << "Unknown command\n";
        -:  244:               }
        -:  245:            }
    #####:  246:        }
        -:  247:
        -:  248:        // Handle new TCP connections
    #####:  249:        if (FD_ISSET(listener, &read_fds)) {
    #####:  250:            sockaddr_in cli_addr{};
    #####:  251:            socklen_t cli_len = sizeof(cli_addr);
    #####:  252:            int client_fd = accept(listener, (sockaddr*)&cli_addr, &cli_len);
    #####:  253:            if( client_fd < 0) {
    #####:  254:                std::cerr << "Error accepting TCP connection\n";
    #####:  255:                continue;
        -:  256:            }
    #####:  257:            setNonBlocking(client_fd);
    #####:  258:            clients.push_back(client_fd);
    #####:  259:            std::cout << "New TCP client connected: " << inet_ntoa(cli_addr.sin_addr) << ":" << ntohs(cli_addr.sin_port) << "\n";
        -:  260:        }
        -:  261:        // Handle UDP requests
    #####:  262:        if (FD_ISSET(udpSock, &read_fds)) {
        -:  263:            char buf[READ_BUFFER];
    #####:  264:            sockaddr_in cli_addr{};
    #####:  265:            socklen_t cli_len = sizeof(cli_addr);
    #####:  266:            ssize_t n = recvfrom(udpSock, buf, sizeof(buf), 0, (sockaddr*)&cli_addr, &cli_len);
    #####:  267:            if (n < 0) {
    #####:  268:                std::cerr << "Error receiving UDP data\n";
    #####:  269:                break;
        -:  270:            }
        -:  271:            char ip[INET_ADDRSTRLEN];
    #####:  272:            inet_ntop(AF_INET, &cli_addr.sin_addr, ip, sizeof(ip));
    #####:  273:            int port = ntohs(cli_addr.sin_port);
    #####:  274:            std::string peer_id = std::string(ip) + ":" + std::to_string(port);
    #####:  275:            if (udp_peers.insert(peer_id).second) {
    #####:  276:                std::cout << "New UDP client connected: " << peer_id << "\n";
        -:  277:            }
        -:  278:
    #####:  279:            std::string cmd(buf, n);
    #####:  280:            if (!cmd.empty() && cmd.back() == '\n')
    #####:  281:                cmd.pop_back(); // Remove trailing newline
        -:  282:
    #####:  283:            processUDPCommand(udpSock, cmd, cli_addr, cli_len, carbon, oxygen, hydrogen);
    #####:  284:        }
        -:  285:        
    #####:  286:        for(auto it = clients.begin(); it != clients.end();) {
    #####:  287:            int client_fd = *it;
    #####:  288:            if (FD_ISSET(client_fd, &read_fds)) {
        -:  289:                char buffer[READ_BUFFER];
    #####:  290:                ssize_t bytes_read = recv(client_fd, buffer, sizeof(buffer), 0);
    #####:  291:                if (bytes_read <= 0) {
    #####:  292:                    close(client_fd);
    #####:  293:                    it = clients.erase(it);
    #####:  294:                    std::cout << "TCP client disconnected\n";
    #####:  295:                    continue;
        -:  296:                }
    #####:  297:                buffer[bytes_read] = '\0';
    #####:  298:                std::string line(buffer);
    #####:  299:                if (!line.empty() && line.back() == '\n')
    #####:  300:                    line.pop_back();
    #####:  301:                processTCPCommand(client_fd, line, carbon, oxygen, hydrogen);
    #####:  302:            }
    #####:  303:            ++it;
        -:  304:        }
    #####:  305:    }
        -:  306:
    #####:  307:    for(int client_fd : clients) {
    #####:  308:        close(client_fd);
        -:  309:    }
    #####:  310:    close(listener);
    #####:  311:    close(udpSock);
        -:  312:
    #####:  313:    return 0;
       2*:  314:}
